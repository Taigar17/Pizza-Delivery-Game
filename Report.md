# SDL2 Project
## Introduction:

### As stated clearly in the brief the main purpose of this project will be to analyse, design and implement an extension to this SLD2 platform game. With that being said, the main storyline of this game will be centred around our main character the pizza delivery guy. While our main character was on the way to deliver his order he is stopped by bullies and drops his pizza slices, which are scattered across the level. In order to complete his job the main character must recollect all pizza slices and other items apart of the order. However, this task will not be easy as there will be enemies, like bullies, animals or supernatural creatures like ghosts, preventing the main character from completing his orders. (I included supernatural creatures as  the main character does night shifts, so this will the opportunity for more supernatural enemies to attack the main character.)

### From this brief explanation of the game's storyline, we can understand that players can take from the game similar traits the main character has. For instance, the main character can be viewed as hardworking and diligent in regards to his work duties. The main character can also be seen by the player as brave as he is not afraid by his enemies that want to prevent the player from completing the level. These are the main personality traits that the player may admire.   

### After testing the current state of the gameplay I have come to realise that there are multiple bugs in this game, such as the space bar button, which resets the player to the start of the game when pressed instead of jumping. As well as this not only have I realised there is no sound in this game but once the player collects all pizza items the game suddenly closes. To improve the overall gameplay I propose implementing improved features, like a high score or timer to show the player's current progress in the game. Including a timer can increase the pressure for the player as they may want to have the best time when completing a level. This timer would be displayed on the screen while they play, which can mean that adding this feature builds onto the games overall replay ability value. I am confident that including a variety of features, like the one mentioned, will keep the player hooked to the game, even as their skills increase.  

### This platform game is currently missing a menu screen. This would give the player the chance to manually press a button to start the game. Incorporating this element into the game will allow the player interactivity of the game before the gameplay. As well as this having a main menu can allow for the game to display a fragment of their main plot. This has been achieved in most games, such as God of War, The Witcher or the Unchartered franchise.     

### Another possible feature that should be considered executing are enemies in the game, which is one way to increase the level difficulty. For this if the player walks into the enemy then the player will die, as a result the level will restart. This feature opens up the opportunity for a further update of either adding a player health bar or assigning the player lives. Although for a platform game like this implementing player lives, shown through hearts on the top of the screen, may be more suitable as players will be forced to learn and adapt to level designs. We can see from other platform games, like Super Mario Bros, Sonic the Hedgehog, or Cuphead that all these games have implemented a player lives approach. Following this the health bar system is unfeasible for this project as it would require the player to prioritise their judgements about the enemies rather than allowing the health bar to kill the player after walking into the enemy after the fifth encounter. This notion of implementing an enemy leads us to the possibility of including a variety of different enemies with a diverse set of abilities. Doing so would result in preventing the players from collecting all pizza slices easily, therefore making the level harder for players to complete. 

### Following this carrying out this could lead to the potentiality of the main character unlocking other abilities, like a double jump or collecting items that give specific powers, which would be preferable when needing to kill enemies. A further suggestion for a feature that could be implemented is including a new task after collecting all eleven pizza slices. For instance, the player's new objective could be to reach the end of the level without dying or to fight a boss, using a new ability, to complete the level. A feature like this is a prime example of what will keep the player interested as the game and player skill progresses as with each level the main character can unlock the chance at a new ability.

### An alternative suggestion that should be considered is to add other methods of increasing difficulty through the level. For example, this can be achieved through adding killable objects for the players like spikes or huge blocks that will drop in the level. For the player to survive the spike or a huge falling block this will require the player to focus on their timing of when to jump or run. One final suggestion which I could include in the game is creating another level, but this new level will be created to be more complex for the player through the previous features I have briefly mentioned.

### Below I have outlined clearly the features I will implement in this game, along with explanations for each of these. 

### 1) Enemy Implementation - To add a challenge to the game for the player, when attempting to complete the level. To do this I will create a new file, 'obstacle.c', for the following enemy code. I will attempt make the enemy move towards the player and kill the player when each sprite touches. (When the player dies the game will restart.)
### 2) Player Timer - Once the game begins the timer will start, which will increase the tension. The timer's purpose will be to put pressure on the player, as well as increase the challenge for the player. This timer will be displayed in the middle of the screen so the player will be able to see this clearly. To do this I will create a new file and will make sure the timer is clearly drawn out with the texture function.  
### 3) Player Power Up / New ability - This will be activated by a collectable in game item, which will be a glowing orb. Once the player collects this orb, the player can press the space bar button to activate the ability. Including this feature will motivate the player to keep going through the game to test the power they have. The taste of power the player gets can improve player retention in the early part of the game, since they will be more engaged. To do this I will edit the player.c file and entities.c folder to complete this feature. 

### Before I start I have decided first correct the gameplay controls, so testing the game in the future will be smoother. This will be done by temporarily commenting out the the space bar as a jumping option as it will be confusing to players when they undergo the gameplay of the first level. I have chosen to comment it out as this button will be altered during the second feature implementation when the player has an ability. I have also decided to keep the background colour and platform colours the same as it fits the night theme the player will undergo. As these are minor changes I have chosen not to include them in the list of features I intend to implement into this project.
### To be able to extend this code effectively I intend to use an object oriented programming style. This is a concept of 'objects', which can contain data and code in the form of fields or procedures. Throughout development I will be focused on the four principles of object oriented programming; encapsulation, abstraction, inheritance and polymorphism. There are many benefits to using object oriented programming for the creation of this game. For example, most code can be reused through inheritance. As well as this the programs created will be flexibile due to polymorphism. Therefore this will mean that all the C programs written will be effective broken down into bite-sized problems that will be solvable, (one object at a time). Using this programming style will achieve higher quality results for this platform game. For this project I will be using a combination of C and C++ to complete the requirements set for this game. Using C++ is perfect for the object oriented approach I intend to take for this task, especially as it has more features designed for object oriented programming.  
### By the end of this project, I will have extended this game effectively by fulfilling all outlined criteria that will make this game much more functional and enjoyable.
<br></br>

## Design
### In this section of the report I will be going through each feature, describing the designs and approach I will be taking in order to maximise the quality of the overall project. 
### When discussing  each of these features I will explain the process taken with a diagram conveying how each of these features will fit into this game. (The layout of this report will show the order of execution.)  

### Feature 1 - Enemy Implementation Process:
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/97e07a0a719576d2a823b60521f43885/Diagram_01.PNG)
### For this feature I have created a new file called Enemy.c. In this have added code to spawn a ghost character into the game as well as float in the air. When the player interacts with the ghost, by touching it, the player will die resulting in the game closing and the words "You have died" being printed in the console. The player can avoid this enemy in the game by jumping over it. I will also reference this file in the entities.c, entdat01.c and common.h files.    
<br></br>

### Feature 2 - Player Timer Process:
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/4d87f13ff7f0d9a5cde8b707d91ec83c/Diagram_03.PNG)
### Once the game begins the timer will start counting down from five minutes. If the timer reaches zero then the game closes and it will output in the console "You Lose". 
<br></br>

### Feature 3 - Player Power Up Process:
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/3de9a23ef6b0982bd47eb443803f2daa/Diagram_02.PNG)
### This feature will be activated by collecting a floating object in game. The player will be able to use this feature by pressing the space bar to shoot. The player can shoot enemies in their, which can kill them.    


### For each of these features it will be necessary for me to complete these in the languages C and C++ as it would match the rest of the game files. This would also be ideal as the C++ is an object oriented language, which would support the programming style I intend to take. Object oriented programming is the best approach for this game as it helps creates maintainable code that is understandable, adaptable and extendable. It also helps create reusable code through inheritance, which will save alot of time when coding. As I am an inexperienced programmer C++ is a good high level language that can teach me the basics of oject oriented programming. Ultimately, this means this programming style is the most effective as is has the more ideal way to organise code in a video game.
### Subsequent to this all code will written in visual studio and has been pushed to this report, where all the progress of my code can be seen. 
### The whole project can be located in cs1pr-portfolio<project<visual-studio<SpringProjectx. However, I will be referencing parts of the completed code in the screenshots markdown, in cs1pr-portfolio<Code_Screennshot.md.
<br></br>

## Implementation and Development

### Descriptions of Final Implementations:
### Feature 1 - Enemy Implementation Process
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/21f022b9e576ad3f9eb55e627e6dbd81/EnemyCode.PNG)
### (This code can be found in Enemy.c & linked to Common.h)
### As you can see in the code above I have attempted to stick to what I had discussed in the design section. However, I am currently having a problem loading the ghost enemy onto the screen. Since there are no errors in the code I cannot determine where I have gone wrong and if the other features, such as the player touch will work. After I have implemented a new function I have run it to test for bugs so the game can be bug free. I attempted to break the code to see if the code was linked, but this then resulted in the game crashing and not opening. Another possibility is the image used does not fit the game, however I did try this with afew other images of different formats and still had no luck getting the enemy to appear on my screen. As each function I have written has no errors in the console it is hard to determine what and where the issue is. As I am running low on time for this project I will return to this feature once I have completed the other two main features I plan on implementing. 
### From this screenshot I have added some comments to briefly explain the purpose for specific lines and functions. In this code I wrote a tick function, touch function and a initGhost function. In the initGhost function I appended the enemy onto a stack for it to be drawn and loaded onto the screen. It will float in the air with the weightless function and if the player touched the enemy through the 'touch' function the player dies. When this happens the exit(1) is activated with the game then closing. In a future update, once all the bugs are fixed I would like to add a game over screen. However, for now I have added a print statement to output in the console if the player has died. I would also like to add a doGhost() function, which I did begin to setup. In this function I would have the ghost appearing from the left side of the screen following the players movements to add pressure to the player. To do this I would add a ghostMove() and create an enemy AI to follow the player's position at a slow pace. Doing so would force the player to find the consumable to activate their power up. Another element I would like to implement for the ghost element is to give it a power that could kill the player. 

### Feature 2 - Player Timer Process:
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/5d96f11336c506457b87614abe261e21/TimerCurrent2.PNG)
![Image](https://csgitlab.reading.ac.uk/vo010497/cs1pr-portfolio/uploads/4beccdb745291ed748aba623f700145e/TimerCurrent3.PNG)
### (This code can be found in main.c & stage.c)
### To complete this feature I had to undergo alot of trial and error with my code. After every tweak I made I would retest the code. 
### I first added to the SDL_GetTicks() function, in the main.c code and was able to output in the console the number of ticks that game has. I was then able to draw this onto the game screen using the drawHud() function, which originally appeared on the right of the screen next to the pizza total. After adding the if statement I was able to convert the ticks to seconds and milliseconds as that was the main issue I was having. I would like to come back to this feature and refine it by only including the seconds.  
### When testing the gameplay the player will see that once the game begins so does the time on the left hand side of the screen. This timer is designed to put pressure on the player as well as encourage them to replay this level through the player wanting to speedrun this game. 
### As I mentioned previously, I had wanted this feature to originally countdown and then exit. I will alter this due the lack of time to count up instead, with this time being possibly used in other instances. For instance, it could be used to determine the player's highcore or once the timer has reached five minutes the game ends and the player has lost. This last part could be displayed on the screen with a 'You Lose' screen. Unlike the last feature there are no bugs as they were dealt with as I was developing this feature. This feature will enable alot more opportunities for other features that can link ton this one.

### Feature 3 - Player Power Up Process:
### Unfortunately I was unable to begin this feature as I have run out of time. Otherwise I would have created a file called consumable.c included functions like (entity* consumable), loadTexture, and assigned the space bar to shoot a fire image out. The space button would have been altered on the player.c file. The space button would have been chosen as it is a simple button for the player to press. I would have extended this further by changing the player attire when they interacted with the consumable as well as make enemies killable and added a sound effect to show the player the change in abilities. This would have been done by adding a new function in the player.c file that would change player textures if the player and consumable touched. Making the enemies killable would have been updated in the Enemy.c file where the 'touch' function could be altered to change the enemy health to 0, which would stop drawing it on the screen. To add the sound I would loadSounds in the sound.c file and set it to activate once the player has touched the consumable.       

<br></br>

## Conclusion
### Considering all the factors we have discussed, it's clear to conclude that I have acquired a lot of knowledge from extending this game. For instance, I have been able to see how much I have applied in the C++ classes to the creation of this game. A main factor I have become a lot more familiar with is GitLab, as I have learnt how to link repositories to visual studio and learned much more about applying object oriented programming in my game code. I have also learnt that game development is not as straight forward, due to the constant testing and debugging that is required throughout the process.
### In regards to the extension of this game I severely underestimated the time taken that would be required to implement these features. In addition to this I didn't consider the constant debugging that would be required for this project. This factor was the most time consuming as having a time constraint was the biggest element that prevented me from completing all features I had outlined in my introduction.  The time constraint I have faced have been caused by have other ongoing coursework's as well as tests. If there was a way to change component I would have had the chance to implement more features into this game. I would have also spent more time understanding the current files and code in the game as I found it extremely hard to understand and navigate through. Following this when I first started this project I had quite afew issue setting up a functional repository that would allow me to push or commit any code I have added or amended. With that being said through all these issues I have had I have been able to overcome them. Thus, learning alot about this how to set one up effectively if I am required to. Looking back at this I realise that a project like this requires alot of patience with all the bugs that a programmer will come across during development. For this project to have been more successful, I should have given myself much more time as I am a very inexperienced programmer.       
### If I had more time I would have developed the current features further, as well as adding a high score points system, another level, a player life system and even a levelling system. Adding a new objective to fit the premise of the game would had been another element I had wanted to complete. Returning to the features I did implement, if I had the chance to I would have fixed and finished extending the enemy feature by making the enemy move to follow or chase the player around the game, (through a doGhost() function), as well as give the ghost a power to kill the player through spitting fire. 
### To sum up, on reflection to how this project was developed there are definitely some changes I would have done to increase the quality of the extended features. 
<br></br>
